---
title: 你所需要了解关于高并发的常识
comments: true
cover: cover.png
date: 2023-09-11 11:31:31
categories:
- Python
keyword: 高并发,多进程,多线程,协程
tags:
- 原创
---

# 多进程、多线程、协程

## 它们的区别

### 多进程
- 每个进程都有自己独立的内存空间，相互之间不会干扰。进程是操作系统分配资源的最小单位。
- 多进程适合于CPU密集型任务，可以利用多核处理器的优势，并且进程之间可以并行执行。
- 由于进程之间需要切换上下文，因此进程间通信比较复杂，需要使用特定的方法（如队列、管道等）。

### 多线程
- 线程是进程内的执行单位，共享进程的内存空间。多个线程共享同一进程的资源。
- 多线程适合于I/O密集型任务，可以在等待I/O操作时切换到其他线程，提高效率。
- 由于使用全局解释器锁（GIL），Python 的多线程无法充分利用多核处理器的优势。在 CPU 密集型任务中，多线程可能不如多进程效果好。

### 协程
- 协程是一种用户级的轻量级线程，由用户控制切换的时机。协程可以在一个线程中实现并发。
- 协程通过 yield 关键字进行挂起和恢复，可以在不同的协程之间切换执行，避免了线程切换的开销。
- 协程适合于高并发的网络编程或异步任务，在I/O密集型场景中效果非常好。通过使用异步框架（如asyncio）、生成器或第三方库（如gevent）来实现

多进程通常使用进程对象和队列来实现进程间的数据传递和同步。多线程通常使用线程对象和锁来实现线程间的同步与通信。协程通常使用异步async/等待await关键字和事件循环来定义和管理协程。

## CPU密集型任务和I/O密集型任务

- CPU密集型任务（CPU-bound）： CPU密集型任务指的是任务主要消耗CPU资源的计算任务。这些任务通常需要大量的CPU运算，例如复杂的数学计算、图像/视频处理、科学模拟等。在这种任务中，CPU的计算能力是影响任务执行速度的主要瓶颈，而I/O操作相对较少。
- I/O密集型任务（I/O-bound）： I/O密集型任务指的是任务主要消耗I/O资源的任务。这些任务通常需要频繁地进行输入/输出操作，如磁盘读写、网络通信、数据库访问等。在这种任务中，任务的执行速度主要受限于I/O操作的速度，而CPU的计算能力相对较少成为瓶颈。

## 线程锁

### 全局解释器锁（GIL）
简单来说，是一种互斥锁（或锁），只允许一个线程控制 Python 解释器。
这意味着在任何时间点只有一个线程可以处于执行状态。GIL 的影响对于执行单线程程序的开发人员来说是不可见的，但它可能是 CPU 密集型和多线程代码中的性能瓶颈。

### 线程安全
线程安全是多线程或多进程编程中的一个概念，在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

### 锁的作用
> 锁是Python提供给我们能够自行操控线程切换的一种手段，使用锁可以让线程的切换变的有序。
> 一旦线程的切换变的有序后，各个线程之间对数据的访问、修改就变的可控，所以若要保证线程安全，就必须使用锁。

threading模块中提供了5种最常见的锁，下面是按照功能进行划分：
- 同步锁：lock（一次只能放行一个）
- 递归锁：rlock（一次只能放行一个）
- 条件锁：condition（一次可以放行任意个）
- 事件锁：event（一次全部放行）
- 信号量锁：semaphore（一次可以放行特定个）

### 同步锁Lock
1. 互斥指的是某一资源同一时刻仅能有一个访问者对其进行访问，具有唯一性和排他性，但是互斥无法限制访问者对资源的访问顺序，即访问是无序的
2. 同步是指在互斥的基础上（大多数情况），通过其他机制实现访问者对资源的有序访问
3. 同步其实已经实现了互斥，是互斥的一种更为复杂的实现，因为它在互斥的基础上实现了有序访问的特点

### 死锁现象
对于同步锁来说，一次acquire()必须对应一次release()，不能出现连续重复使用多次acquire()后再重复使用多次release()的操作，这样会引起死锁造成程序的阻塞，完全不动了
由于threading.Lock()对象中实现了enter__()与__exit()方法，故我们可以使用with语句进行上下文管理形式的加锁解锁操作
```python
def add():
    with lock:
        # 自动加锁
        global num
        for i in range(10_000_000):
            num += 1
        # 自动解锁
```

### 递归锁RLock
递归锁是同步锁的一个升级版本，在同步锁的基础上可以做到连续重复使用多次acquire()后再重复使用多次release()的操作，但是一定要注意加锁次数和解锁次数必须一致，否则也将引发死锁现象。

### 条件锁Condition
条件锁是在递归锁的基础上增加了能够暂停线程运行的功能。并且我们可以使用wait()与notify()来控制线程执行的个数。

### 事件锁Event
事件锁是基于条件锁来做的，它与条件锁的区别在于一次只能放行全部，不能放行任意个数量的子线程继续运行。
我们可以将事件锁看为红绿灯，当红灯时所有子线程都暂停运行，并进入“等待”状态，当绿灯时所有子线程都恢复“运行”。

### 信号量锁Semaphore
信号量锁也是根据条件锁来做的，它与条件锁和事件锁的区别如下：
- 条件锁：一次可以放行任意个处于“等待”状态的线程
- 事件锁：一次可以放行全部的处于“等待”状态的线程
- 信号量锁：通过规定，成批的放行特定个处于“上锁”状态的线程

## 协程
定义协程的方式：
1. 通过async def定义且通过return返回值的函数为协程函数。协程函数的返回对象称为协程对象，是可等待对象的一种。
2. 协程对象由await或asyncio.run()进行驱动，await只能用于async def定义的函数体中。
3. asyncio.gather()用来并发运行可等待对象序列。
4. 通过async def定义且通过yield返回值的函数为协程生成器，可以用async for来进行迭代。
5. 能够被await驱动的对象类型称为awaitable，即可等待对象。在Python标准库中，定义了特殊方法__await__()的对象都是可等待对象，主要有三类：coroutine，Task，Future。其中，coroutine就是协程函数的返回对象；Task为asycio.create_task(coroutine)的返回对象。
6. 不使用await或asyncio.run驱动，而是直接调用协程函数，则协程函数会返回一个协程对象。

从执行结果可以观察到很重要的一点：被驱动的协程对象都是立即返回，尽管最终的结果还未得到。其实协程本质上只是在用户程序和低层线程之间搭建了一个”管道“，从而把协程调度的工作委派了事件循环。我们不需要知道低层的运作原理，我们只需要确保在我们的代码中没有阻塞的代码，事件循环会在背后替我们处理并发。

引用自协程相比多线程有两点优势：
1. 没有线程切换的开销。
2. 因为协程都是运行在一个线程上的，不存在由于多线程的”竞争机制“导致的同时写变量冲突等问题。因此，在协程中对于共享资源不需要加锁。